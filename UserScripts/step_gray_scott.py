
def update_threaded(dt):
    """
    Реалистичная 2D-сцена: реакционно-диффузионная система Gray–Scott на решётке.
    Уравнения (безразмерно):
        ∂_t U = D_u ΔU - U V^2 + F (1 - U)
        ∂_t V = D_v ΔV + U V^2 - (F + k) V
    Интегратор: явный явный шаг (Euler) с малым dt; периодические ГУ.
    Визуализация: карта цветов по комбинации U/V, стрелки потока (необяз.), HUD.
    """
    position = (0, 0)
    cx, cy = position



    # --- Инициализация один раз ---
    if not hasattr(self, "_gs_init"):
        self._gs_init = True

        # сетка и параметры модели
        self._Nx = 100
        self._Ny = 100
        self._a = 1.0
        # физические параметры Gray-Scott — приводят к богатой паттерн-динамике
        self._Du = 0.16  # диффузия U
        self._Dv = 0.08  # диффузия V
        self._F = 0.035  # скорость поступления U
        self._k = 0.065  # отток V
        self._dt = 1.0  # шаг времени (годится для таких параметров, но смотреть стабилизацию)

        # поля U и V
        Nx, Ny = self._Nx, self._Ny
        self._U = [[1.0 for _ in range(Ny)] for _ in range(Nx)]
        self._V = [[0.0 for _ in range(Ny)] for _ in range(Nx)]

        # начальное возмущение: центр небольшой квадратик с повышенной V
        cx_i = Nx // 2
        cy_j = Ny // 2
        r = min(Nx, Ny) // 12
        for i in range(Nx):
            for j in range(Ny):
                # добавим немного шумa по всей сетке
                self._U[i][j] = 1.0 - 0.02 * random.random()
                self._V[i][j] = 0.02 * random.random()
                # центральный блок с удалением U и добавлением V
                if abs(i - cx_i) < r and abs(j - cy_j) < r:
                    self._U[i][j] = 0.50 + 0.02 * (random.random() - 0.5)
                    self._V[i][j] = 0.25 + 0.02 * (random.random() - 0.5)

        self._t = 0.0
        self._viz_skip = 1

    # --- Вспомогательные функции PBC и лапласиан ---
    Nx, Ny = self._Nx, self._Ny
    a, dt = self._a, self._dt
    Du, Dv = self._Du, self._Dv
    F, k = self._F, self._k

    def idx(i, n):
        return (i + n) % n

    def laplacian(field, i, j):
        # пятиточечная формула
        return (field[idx(i + 1, Nx)][j] + field[idx(i - 1, Nx)][j] +
                field[i][idx(j + 1, Ny)] + field[i][idx(j - 1, Ny)] -
                4.0 * field[i][j]) / (a * a)

    # --- Один явный шаг (Euler) для реакционно-диффузионной системы ---
    U, V = self._U, self._V
    newU = [[0.0 for _ in range(Ny)] for _ in range(Nx)]
    newV = [[0.0 for _ in range(Ny)] for _ in range(Nx)]

    for i in range(Nx):
        for j in range(Ny):
            Lu = laplacian(U, i, j)
            Lv = laplacian(V, i, j)
            uvv = U[i][j] * (V[i][j] ** 2)  # U V^2

            # реакция + диффузия
            dU = Du * Lu - uvv + F * (1.0 - U[i][j])
            dV = Dv * Lv + uvv - (F + k) * V[i][j]

            # явный Euler
            newU[i][j] = U[i][j] + dt * dU
            newV[i][j] = V[i][j] + dt * dV

            # численные ограничения (физически: 0..1)
            if newU[i][j] < 0.0: newU[i][j] = 0.0
            if newU[i][j] > 1.0: newU[i][j] = 1.0
            if newV[i][j] < 0.0: newV[i][j] = 0.0
            if newV[i][j] > 1.0: newV[i][j] = 1.0

    self._U = newU
    self._V = newV
    self._t += dt
    grid_px = 4.0
    halfx = (Nx * grid_px) / 2
    halfy = (Ny * grid_px) / 2
    Gizmos.draw_rect((cx, cy), Nx * grid_px, Ny * grid_px,
                     color=(30, 30, 30), filled=False, thickness=2, world_space=True)

    for i in range(Nx):
        for j in range(Ny):
            u = self._U[i][j]
            v = self._V[i][j]
            r = int(255 * max(0.0, min(1.0, v)))
            g = int(255 * max(0.0, min(1.0, u)))
            b = int(255 * max(0.0, min(1.0, (1.0 - u) * v * 2.0)))
            px = cx - halfx + (i + 0.5) * grid_px
            py = cy - halfy + (j + 0.5) * grid_px
            Gizmos.draw_rect((px, py), grid_px * 0.98, grid_px * 0.98,
                             color=(r, g, b), filled=True, world_space=True)

    # HUD
    Gizmos.draw_text((cx - halfx + 8, cy - halfy - 20),
                     f"t = {self._t:.1f}, F={F}, k={k}, Du={Du}, Dv={Dv}",
                     font_size=14, color=(230, 230, 230), world_space=True)

    Gizmos.draw_text(
        (cx - halfx + 8, cy - halfy - 120),
        """Что это такое (Gray–Scott, в терминах этой реализации)
Gray–Scott — простая реакционно-диффузионная система с двумя концентрациями U и V. На сетке реализуются две PDE:
    ∂_t U = D_u ΔU - U V^2 + F (1 - U)
    ∂_t V = D_v ΔV + U V^2 - (F + k) V
Здесь D_u, D_v — коэффициенты диффузии, F — скорость подпитки вещества U, k — темп удаления вещества V.

Зачем это интересно
• Паттернообразование: модель демонстрирует образование полос, пятен, спиралей и лабиринтов — классика самоупорядочения.  
• Исследование маршрутов из однородности в структурированное состояние (Turing-like механизмы).  
• Тестирование численных схем для реакционно-диффузионных систем и визуализация нелокальных эффектов.  
• Художественные визуализации — из тех же уравнений получаются красивые фракталоподобные структуры.

Ключевые элементы и их роль
1. U, V — поля концентраций, хранятся в узлах сетки.  
2. Лапласиан — отвечает за пространственное взаимораспределение (диффузию).  
3. Нелинейная реакция U V^2 — ключ к экспоненциальному росту V при наличии U; реакция + отток/подпитка задают баланс.  
4. Параметры (F, k, Du, Dv) определяют режим — разные пары (F,k) дают совершенно разные стабильные/нестабильные паттерны.  
5. PBC — убирают граничные эффекты, результат определяется только локальной динамикой и случайными флуктуациями.

Как это работает пошагово
0. Инициализация: U ≈ 1, V ≈ 0 плюс локальное возмущение (центральный «квадрат») — источник генерации структуры.  
1. На каждом шаге вычисляем ΔU и ΔV (лапласиан).  
2. Считаем нелинейные члены: -U V^2 (истощение U) и +U V^2 (порождающий V).  
3. Добавляем подпитку F(1−U) и отток (F+k)V.  
4. Обновляем U и V явным шагом: U ← U + dt * (...); V ← V + dt * (...).  
5. Ограничиваем значения (чтобы избежать числового дрейфа за пределы 0..1).  
6. Рисуем карту цветов — реакционно-диффузионный узор виден сразу.

Практические замечания
• Стабильность: явный шаг требует dt маленьким при больших коэффициентах диффузии; dt=1 бывает приемлем при выбранных Du/Dv, но при изменении параметров следует уменьшить dt.  
• Выбор начального условия: небольшой шум по всей сетке + локальный дефект запускают разные сценарии.  
• Параметрное разнообразие: варьируйте F и k, чтобы получить пятна, полосы, спирали; в литературе есть карты фаз в пространстве (F,k).  
• Оптимизация: для интерактивных демонстраций можно уменьшить Nx×Ny или рисовать каждый N-й кадр.

Интерпретация результатов
• При некоторых (F,k) вы увидите стабильные пятнистые паттерны; при других — клетки и полосы; ещё при других — динамически меняющиеся лабиринты.  
• Модель — отличный инструмент для интерактивной визуализации самоорганизации и для демонстрации, как простые локальные правила приводят к сложным глобальным структурам.

Коротко: Gray–Scott — компактная, визуально богатая система для изучения паттернообразования, численных методов и нелинейной динамики.""",
        font_size=16,
        color='white',
        world_space=True,
        font_world_space=True,
    )